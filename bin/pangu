#!/usr/bin/env node

var commander = require('commander');
var fs = require('fs');
var pangu = require('../index');

commander
  .version(require('../package.json').version)
  .usage('[options] <filepath>')
  .option('-v, --version', 'Pangu version.')
  .option('-f, --file <filepath>', 'Format file.')
  .option('-d, --dir <dirpath>', 'Format files in dir.')
  .option('-i, --in-place <extension>', 'Edit files in-place, saving backups with the specified extension.')
  .parse(process.argv);

if (commander.args.length === 0) {
  commander.help();
}


function fixup (filepath) {

}

var RE_MARKDOWN = /\.(?:md|markd|markdown)$/i;
var RE_TEXT = /\.text$/i;

var filepaths = commander.args;

filepaths.forEach(function(filepath) {
  var options = {};
  if (RE_MARKDOWN.test(filepath)) {
    options.file_type = 'markdown';
  } else if (RE_TEXT.test(filepath)) {
    options.file_type = 'text';
  } else {
    console.error('Not support file: ' + filepath);
  }

  var text = fs.readFile(filepath, {encoding: 'utf8'}, function(err, text) {
    if (err) {
      return console.error('Read file %s error: %s', filepath, err.message);
    }
    var spaced = pangu(text);
    if (commander.inPlace === undefined) {
      console.log(spaced);
    } else {
      fs.writeFile(filepath + commander.inPlace, spaced, function(ex) {
        if (err) {
          console.error('Write file %s failed: %s', filepath, ex.message);
        }
      });
    }
  });
});

// vim:ft=javascript
